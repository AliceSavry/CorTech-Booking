<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>NEON TETRA BLOCKS</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        :root {
            --neon-pink: #ff00ff;
            --neon-cyan: #00ffff;
            --neon-yellow: #ffff00;
            --bg-dark: #0f0f1a;
        }

        * { box-sizing: border-box; }

        html, body {
            background-color: #050505;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, #00ffff 2px, #00ffff 4px);
            background-size: 100% 4px;
            color: white;
            font-family: 'Press Start 2P', cursive;
            width: 100%;
            height: 100%;
            overflow: hidden; 
            touch-action: none; 
            display: flex;
            flex-direction: column;
        }

        /* HEADER */
        header {
            flex: 0 0 auto;
            padding: 5px;
            text-align: center;
            z-index: 20;
            background: rgba(0,0,0,0.5);
        }

        /* ZONE DE JEU */
        #main-container {
            flex: 1 1 auto;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            width: 100%;
            min-height: 0;
            padding: 5px;
        }

        /* CADRE DU JEU */
        #arcade-frame {
            border: 4px solid var(--neon-pink);
            box-shadow: 0 0 20px var(--neon-pink), inset 0 0 20px var(--neon-cyan);
            background: rgba(0, 0, 0, 0.9);
            position: relative;
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 300 / 600;
            width: auto;
            height: auto;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        /* CONTROLES MOBILE (Fixe en bas) */
        #mobile-controls {
            flex: 0 0 auto;
            height: 100px;
            width: 100%;
            background: #111;
            border-top: 2px solid var(--neon-cyan);
            display: grid;
            grid-template-columns: 1fr 1fr 1fr; /* Gauche, Bas, Droite */
            gap: 4px;
            padding: 4px;
            z-index: 100;
        }

        /* BOUTON ROTATION LATERAL (Mobile ET PC) */
        #btnRotateFloat {
            position: absolute;
            top: 50%;
            right: 20px; /* Un peu décalé du bord */
            transform: translateY(-50%);
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 0, 255, 0.2);
            border: 3px solid var(--neon-pink);
            color: var(--neon-pink);
            display: flex; justify-content: center; align-items: center;
            font-size: 40px;
            z-index: 101;
            box-shadow: 0 0 15px var(--neon-pink);
            pointer-events: auto;
            touch-action: manipulation;
            cursor: pointer;
        }
        #btnRotateFloat:active {
            background: var(--neon-pink);
            color: white;
            transform: translateY(-50%) scale(0.95);
        }

        .ctrl-btn {
            background: #222;
            border: 1px solid #444;
            border-radius: 8px;
            color: white;
            font-size: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            cursor: pointer;
        }
        .ctrl-btn:active, .ctrl-btn.active {
            background: var(--neon-cyan);
            color: black;
        }

        /* NEXT PIECE */
        #next-piece-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 60px;
            height: 60px;
            border: 2px solid var(--neon-yellow);
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }
        #nextCanvas { width: 40px; height: 40px; }

        /* OVERLAYS */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex; flex-direction: column; 
            justify-content: center; align-items: center;
            z-index: 50;
        }
        
        .neon-title { font-family: 'Fredoka One', cursive; text-shadow: 0 0 10px var(--neon-pink); }
        .hidden { display: none !important; }

        #muteBtn {
            position: absolute; top: 10px; right: 10px;
            font-size: 9px; padding: 4px 8px;
            border: 1px solid var(--neon-yellow);
            color: var(--neon-yellow);
            background: black;
            z-index: 60;
            cursor: pointer;
        }

        /* MODIFICATIONS PC (Desktop) */
        @media (min-width: 768px) {
            /* On cache SEULEMENT les flèches du bas */
            #mobile-controls { display: none; }
            
            /* On GARDE le bouton Rotate, mais on peut ajuster sa position si besoin */
            #btnRotateFloat { 
                right: 10%; /* Plus centré sur les écrans larges */
            }
            
            #arcade-frame { height: 90%; }
        }
    </style>
</head>
<body>

    <header>
        <h1 class="text-2xl md:text-4xl text-white neon-title">NEON TETRA</h1>
        <button id="muteBtn">SON: ON</button>
    </header>

    <div id="main-container">
        <div id="arcade-frame">
            <canvas id="gameCanvas" width="300" height="600"></canvas>
            
            <div id="next-piece-overlay">
                <div class="text-[8px] text-yellow-300 mb-1">NEXT</div>
                <canvas id="nextCanvas" width="80" height="80"></canvas>
            </div>

            <div id="startScreen" class="overlay">
                <h2 class="text-yellow-400 text-xl mb-4 text-center animate-pulse">INSERT COIN</h2>
                <div class="text-[10px] text-cyan-300 mb-4 text-center leading-loose">
                    PC: FLÈCHES + HAUT(Rotate)<br>
                    MOBILE: TOUCH
                </div>
                <button id="startBtn" class="px-6 py-3 border-2 border-cyan-400 text-cyan-400 hover:bg-cyan-400 hover:text-black font-bold text-sm pointer-events-auto cursor-pointer">JOUER</button>
            </div>

            <div id="gameOverScreen" class="overlay hidden">
                <h2 class="text-red-500 text-2xl mb-2 neon-title">GAME OVER</h2>
                <div class="text-white text-sm mb-4">SCORE: <span id="finalScore" class="text-yellow-400">0</span></div>
                
                <div id="highScoreForm" class="hidden flex flex-col items-center gap-2 mb-4">
                    <div class="text-green-400 text-[10px]">NOUVEAU RECORD !</div>
                    <div class="flex gap-2">
                        <input type="text" id="playerName" maxlength="3" class="bg-black border border-white text-white p-2 w-20 text-center uppercase pointer-events-auto" placeholder="NOM">
                        <button id="saveScoreBtn" class="bg-green-600 text-white px-2 text-xs pointer-events-auto cursor-pointer">OK</button>
                    </div>
                </div>

                <button id="restartBtn" class="px-6 py-3 border-2 border-pink-500 text-pink-500 font-bold text-sm pointer-events-auto cursor-pointer">REJOUER</button>
            </div>

            <div class="absolute top-2 left-2 text-[10px] text-white opacity-70 pointer-events-none">
                SCORE: <span id="hud-score">0</span>
            </div>
        </div>
        
        <div id="btnRotateFloat">↻</div>
    </div>

    <div id="mobile-controls" class="md:hidden">
        <div id="btnLeft" class="ctrl-btn">←</div>
        <div id="btnDown" class="ctrl-btn">↓</div>
        <div id="btnRight" class="ctrl-btn">→</div>
    </div>

    <script>
        // Prevention Zoom
        document.addEventListener('gesturestart', function(e) { e.preventDefault(); });
        document.addEventListener('touchmove', function(e) { if(e.scale !== 1) { e.preventDefault(); } }, { passive: false });

        /** AUDIO ENGINE **/
        class SoundEngine {
            constructor() {
                this.ctx = null;
                this.isMuted = false;
            }
            init() {
                if(!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if(this.ctx.state === 'suspended') this.ctx.resume();
            }
            toggleMute() {
                this.isMuted = !this.isMuted;
                document.getElementById('muteBtn').innerText = this.isMuted ? "SON: OFF" : "SON: ON";
            }
            playTone(freq, type='square', duration=0.1) {
                if(this.isMuted || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }
            playMove() { this.playTone(200, 'triangle', 0.05); }
            playRotate() { this.playTone(400, 'square', 0.05); }
            playDrop() { this.playTone(100, 'sawtooth', 0.1); }
            playClear() { 
                this.playTone(600, 'square', 0.1); 
                setTimeout(()=>this.playTone(800, 'square', 0.2), 100);
            }
            playGameOver() {
                this.playTone(300, 'sawtooth', 0.3);
                setTimeout(()=>this.playTone(200, 'sawtooth', 0.3), 300);
            }
        }

        /** GAME LOGIC **/
        const COLS = 10; const ROWS = 20; const BLOCK_SIZE = 30;
        const SHAPES = [
            [[1, 1, 1, 1]], [[1, 0, 0], [1, 1, 1]], [[0, 0, 1], [1, 1, 1]], [[1, 1], [1, 1]], [[0, 1, 1], [1, 1, 0]], [[0, 1, 0], [1, 1, 1]], [[1, 1, 0], [0, 1, 1]]
        ];
        const COLORS = ['#00ffff', '#3b82f6', '#f97316', '#ffff00', '#22c55e', '#d946ef', '#ef4444'];

        class TetrisGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.nextCanvas = document.getElementById('nextCanvas');
                this.nextCtx = this.nextCanvas.getContext('2d');

                this.audio = new SoundEngine();
                
                this.grid = this.createGrid();
                this.score = 0;
                this.gameOver = false;
                
                this.piece = null;
                this.nextPieceObj = null;
                this.dropCounter = 0;
                this.dropInterval = 1000;
                this.lastTime = 0;

                this.setupInputs();
                
                // Dessin initial
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0,0,300,600);
            }

            createGrid() { return Array.from({ length: ROWS }, () => Array(COLS).fill(0)); }

            reset() {
                this.grid = this.createGrid();
                this.score = 0;
                this.gameOver = false;
                this.dropInterval = 1000;
                this.piece = this.randomPiece();
                this.nextPieceObj = this.randomPiece();
                
                document.getElementById('hud-score').innerText = 0;
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.add('hidden');
                this.audio.init();
                this.loop();
            }

            randomPiece() {
                const typeId = Math.floor(Math.random() * SHAPES.length);
                return {
                    shape: SHAPES[typeId],
                    color: COLORS[typeId],
                    x: Math.floor(COLS / 2) - Math.floor(SHAPES[typeId][0].length / 2),
                    y: 0
                };
            }

            drawBlock(ctx, x, y, color, size, isGhost = false) {
                if (isGhost) {
                    ctx.fillStyle = 'transparent'; ctx.strokeStyle = color; ctx.lineWidth = 1;
                    ctx.strokeRect(x * size, y * size, size, size);
                    ctx.fillStyle = color + '22'; ctx.fillRect(x * size, y * size, size, size);
                } else {
                    ctx.fillStyle = color; ctx.shadowBlur = 10; ctx.shadowColor = color;
                    ctx.fillRect(x * size, y * size, size, size);
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillRect(x * size, y * size, size, 2); ctx.fillRect(x * size, y * size, 2, size);
                    ctx.strokeStyle = '#000'; ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                }
            }

            draw() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, 300, 600);

                this.grid.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) this.drawBlock(this.ctx, x, y, value, BLOCK_SIZE);
                    });
                });

                if (this.piece) {
                    const ghost = { ...this.piece };
                    while (!this.collide(ghost)) { ghost.y++; } ghost.y--;
                    if (ghost.y > this.piece.y) {
                        ghost.shape.forEach((row, y) => {
                            row.forEach((value, x) => {
                                if (value) this.drawBlock(this.ctx, ghost.x + x, ghost.y + y, this.piece.color, BLOCK_SIZE, true);
                            });
                        });
                    }
                    this.piece.shape.forEach((row, y) => {
                        row.forEach((value, x) => {
                            if (value) {
                                this.drawBlock(this.ctx, this.piece.x + x, this.piece.y + y, this.piece.color, BLOCK_SIZE);
                            }
                        });
                    });
                }

                // NEXT PIECE
                this.nextCtx.fillStyle = '#000';
                this.nextCtx.fillRect(0, 0, 80, 80);
                if (this.nextPieceObj) {
                    const scale = 15;
                    const offsetX = (80 - this.nextPieceObj.shape[0].length * scale) / 2;
                    const offsetY = (80 - this.nextPieceObj.shape.length * scale) / 2;
                    this.nextPieceObj.shape.forEach((row, y) => {
                        row.forEach((value, x) => {
                            if (value) {
                                this.nextCtx.fillStyle = this.nextPieceObj.color;
                                this.nextCtx.fillRect(offsetX + x*scale, offsetY + y*scale, scale, scale);
                                this.nextCtx.strokeStyle = '#000';
                                this.nextCtx.strokeRect(offsetX + x*scale, offsetY + y*scale, scale, scale);
                            }
                        });
                    });
                }
            }

            collide(piece) {
                for (let y = 0; y < piece.shape.length; ++y) {
                    for (let x = 0; x < piece.shape[y].length; ++x) {
                        if (piece.shape[y][x] !== 0 &&
                            (this.grid[piece.y + y] &&
                            this.grid[piece.y + y][piece.x + x]) !== 0) {
                            return true;
                        }
                    }
                }
                return false;
            }

            merge() {
                this.piece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            this.grid[this.piece.y + y][this.piece.x + x] = this.piece.color;
                        }
                    });
                });
            }

            rotate() {
                const rotated = this.piece.shape[0].map((_, i) => this.piece.shape.map(row => row[i]).reverse());
                const prevShape = this.piece.shape;
                this.piece.shape = rotated;
                if (this.collide(this.piece)) {
                    this.piece.x++;
                    if (this.collide(this.piece)) {
                        this.piece.x -= 2;
                        if (this.collide(this.piece)) {
                            this.piece.x++;
                            this.piece.shape = prevShape;
                            return;
                        }
                    }
                }
                this.audio.playRotate();
            }

            arenaSweep() {
                let rowCount = 0;
                outer: for (let y = this.grid.length - 1; y > 0; --y) {
                    for (let x = 0; x < this.grid[y].length; ++x) {
                        if (this.grid[y][x] === 0) continue outer;
                    }
                    const row = this.grid.splice(y, 1)[0].fill(0);
                    this.grid.unshift(row);
                    ++y;
                    rowCount++;
                }
                if (rowCount > 0) {
                    this.score += rowCount * 100;
                    document.getElementById('hud-score').innerText = this.score;
                    this.audio.playClear();
                    if(this.dropInterval > 200) this.dropInterval -= 50;
                }
            }

            playerDrop() {
                this.piece.y++;
                if (this.collide(this.piece)) {
                    this.piece.y--;
                    this.merge();
                    this.audio.playDrop();
                    this.arenaSweep();
                    this.piece = this.nextPieceObj;
                    this.nextPieceObj = this.randomPiece();
                    if (this.collide(this.piece)) {
                        this.gameOver = true;
                        this.audio.playGameOver();
                        document.getElementById('finalScore').innerText = this.score;
                        document.getElementById('gameOverScreen').classList.remove('hidden');
                        
                        // Check Highscore
                        const savedScores = JSON.parse(localStorage.getItem('neonTetrisLB')) || [];
                        const minScore = savedScores.length < 5 ? 0 : savedScores[savedScores.length-1].score;
                        const form = document.getElementById('highScoreForm');
                        const restart = document.getElementById('restartBtn');
                        
                        if(this.score > minScore || savedScores.length < 5) {
                            form.classList.remove('hidden'); form.classList.add('flex'); restart.classList.add('hidden');
                        } else {
                            form.classList.add('hidden'); form.classList.remove('flex'); restart.classList.remove('hidden');
                        }
                    }
                }
                this.dropCounter = 0;
            }

            playerMove(dir) {
                this.piece.x += dir;
                if (this.collide(this.piece)) {
                    this.piece.x -= dir;
                } else {
                    this.audio.playMove();
                }
            }

            update(deltaTime) {
                if (this.gameOver) return;
                this.dropCounter += deltaTime;
                if (this.dropCounter > this.dropInterval) {
                    this.playerDrop();
                }
            }

            loop(time = 0) {
                if (this.gameOver) return;
                const deltaTime = time - this.lastTime;
                this.lastTime = time;
                this.update(deltaTime);
                this.draw();
                requestAnimationFrame(this.loop.bind(this));
            }

            setupInputs() {
                document.addEventListener('keydown', event => {
                    if (this.gameOver) return;
                    if([37,38,39,40].includes(event.keyCode)) event.preventDefault();
                    switch(event.keyCode) {
                        case 37: this.playerMove(-1); break;
                        case 39: this.playerMove(1); break;
                        case 40: this.playerDrop(); break;
                        case 38: this.rotate(); break;
                    }
                });

                // --- GESTION TACTILE ---
                const bindTouch = (id, action, repeat = true) => {
                    const btn = document.getElementById(id);
                    let interval;
                    
                    const trigger = (e) => {
                        if(e.cancelable) e.preventDefault(); 
                        if (this.gameOver) return;
                        
                        btn.classList.add('active');
                        action(); 
                        
                        if(repeat) {
                            clearInterval(interval);
                            interval = setInterval(() => {
                                if(!this.gameOver) action();
                            }, 100); 
                        }
                    };

                    const release = (e) => {
                        if(e.cancelable) e.preventDefault();
                        clearInterval(interval);
                        btn.classList.remove('active');
                    };

                    btn.addEventListener('touchstart', trigger, {passive: false});
                    btn.addEventListener('touchend', release);
                    btn.addEventListener('mousedown', trigger);
                    btn.addEventListener('mouseup', release);
                };

                bindTouch('btnLeft', () => this.playerMove(-1));
                bindTouch('btnRight', () => this.playerMove(1));
                bindTouch('btnDown', () => this.playerDrop());
                bindTouch('btnRotateFloat', () => this.rotate(), false); 

                const startGame = () => { this.audio.init(); this.reset(); };
                document.getElementById('startBtn').addEventListener('click', startGame);
                
                document.getElementById('muteBtn').addEventListener('click', (e) => {
                    e.preventDefault(); this.audio.toggleMute();
                });

                document.getElementById('saveScoreBtn').addEventListener('click', () => {
                    const name = document.getElementById('playerName').value.toUpperCase() || 'UNK';
                    let scores = JSON.parse(localStorage.getItem('neonTetrisLB')) || [];
                    scores.push({name, score: this.score});
                    scores.sort((a,b) => b.score - a.score);
                    scores = scores.slice(0, 5);
                    localStorage.setItem('neonTetrisLB', JSON.stringify(scores));
                    
                    document.getElementById('highScoreForm').classList.add('hidden');
                    document.getElementById('highScoreForm').classList.remove('flex');
                    document.getElementById('restartBtn').classList.remove('hidden');
                });
                document.getElementById('restartBtn').addEventListener('click', startGame);
            }
        }

        const game = new TetrisGame();
    </script>
</body>
</html>
