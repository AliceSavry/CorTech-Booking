<!DOCTYPE html>

<html
lang="fr">

<head>

    <meta
charset="UTF-8">

    <meta
name="viewport"
content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Neko Catch - Kawaii Arcade</title>

    <style>

        :root {

            --pink-bg: 
#ffeaf0;

            --pink-accent: 
#ffb7c5;

            --cat-color: 
#ffffff;

            --ui-font: 
'Segoe UI', Tahoma, 
Geneva, Verdana, 
sans-serif;

        }



        body {

            margin: 
0;

            padding: 
0;

            background-color: 
var(--pink-bg);

            font-family: 
var(--ui-font);

            overflow: 
hidden;

            display: 
flex;

            justify-content: 
center;

            align-items: 
center;

            height: 
100vh;

            touch-action: 
none;

        }



        #game-container {

            position: 
relative;

            width: 
100%;

            max-width: 
500px;

            height: 
100%;

            max-height: 
800px;

            background: 
linear-gradient(to bottom, 
#ffeaf0, #fff5f8);

            box-shadow: 
0 0 
50px rgba(0,0,0,0.1);

            overflow: 
hidden;

            border: 
8px solid 
white;

            border-radius: 
20px;

        }



        canvas {

            display: 
block;

            width: 
100%;

            height: 
100%;

            cursor: 
none;

        }



        #ui-overlay {

            position: 
absolute;

            top: 
20px;

            left: 
20px;

            right: 
20px;

            display: 
flex;

            justify-content: 
space-between;

            pointer-events: 
none;

            z-index: 
10;

        }



        .stat-box {

            background: 
rgba(255, 
255, 255, 
0.8);

            padding: 
10px 20px;

            border-radius: 
15px;

            border: 
3px solid 
var(--pink-accent);

            color: 
#ff6b81;

            font-weight: 
bold;

            font-size: 
1.2rem;

            box-shadow: 
0 4px 
0 var(--pink-accent);

        }



        #start-screen, 
#game-over {

            position: 
absolute;

            inset: 
0;

            background: 
rgba(255, 
234, 240, 
0.95);

            display: 
flex;

            flex-direction: 
column;

            justify-content: 
center;

            align-items: 
center;

            z-index: 
20;

            text-align: 
center;

            padding: 
20px;

        }



        h1 { 
color: #ff6b81; 
font-size: 3rem; 
margin-bottom: 10px; 
text-shadow: 2px 
2px white; }

        p { 
color: #888; 
margin-bottom: 30px; }



        button {

            padding: 
15px 40px;

            font-size: 
1.5rem;

            background-color: 
#ff6b81;

            color: 
white;

            border: 
none;

            border-radius: 
50px;

            cursor: 
pointer;

            box-shadow: 
0 6px 
0 #d6455c;

            transition: 
transform 0.1s, 
box-shadow 0.1s;

            font-weight: 
bold;

        }



        button:active {

            transform: 
translateY(4px);

            box-shadow: 
0 2px 
0 #d6455c;

        }



        .hidden { 
display: none 
!important; }



        /* Effet de particules kawaii */

        .particle {

            position: 
absolute;

            pointer-events: 
none;

            border-radius: 
50%;

            z-index: 
5;

        }

    </style>

</head>

<body>



<div
id="game-container">

    <div
id="ui-overlay">

        <div
class="stat-box">Score:
<span
id="score-val">0</span></div>

        <div
class="stat-box">Vies:
<span
id="lives-val">3</span></div>

    </div>



    <div
id="start-screen">

        <h1>Neko Catch!</h1>

        <p>Attrape les friandises üç∞<br>√âvite
 les bombes üí£<br>Utilise ta souris ou ton doigt !</p>

        <button
id="start-btn">JOUER ‚ú®</button>

    </div>



    <div
id="game-over"
class="hidden">

        <h1>Oupsy ! üêæ</h1>

        <p>Ton score final est de :
<span
id="final-score">0</span></p>

        <button
id="restart-btn">REESSAYER üéÄ</button>

    </div>



    <canvas
id="gameCanvas"></canvas>

</div>



<script>

    /** @type {HTMLCanvasElement} */

    const canvas = document.getElementById('gameCanvas');

    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('score-val');

    const livesEl = document.getElementById('lives-val');

    const finalScoreEl = document.getElementById('final-score');

    const startScreen = document.getElementById('start-screen');

    const gameOverScreen = document.getElementById('game-over');



    // Audio Context pour effets sonores g√©n√©r√©s

    let audioCtx;

    function initAudio() {

        if (!audioCtx) audioCtx =
new (window.AudioContext || window.webkitAudioContext)();

    }



    function playSound(type) {

        if (!audioCtx) 
return;

        const osc = audioCtx.createOscillator();

        const gain = audioCtx.createGain();

        osc.connect(gain);

        gain.connect(audioCtx.destination);



        const now = audioCtx.currentTime;



        if (type === 
'collect') {

            osc.type = 'sine';

            osc.frequency.setValueAtTime(440, now);

            osc.frequency.exponentialRampToValueAtTime(880, now +
0.1);

            gain.gain.setValueAtTime(0.1, now);

            gain.gain.exponentialRampToValueAtTime(0.01, now +
0.1);

            osc.start();

            osc.stop(now + 0.1);

        } else 
if (type === 'hit') {

            osc.type = 'sawtooth';

            osc.frequency.setValueAtTime(150, now);

            osc.frequency.linearRampToValueAtTime(50, now +
0.3);

            gain.gain.setValueAtTime(0.1, now);

            gain.gain.linearRampToValueAtTime(0.01, now +
0.3);

            osc.start();

            osc.stop(now + 0.3);

        }

    }



    // Configuration du jeu

    let gameState = 
'START';

    let score = 
0;

    let lives = 
3;

    let level = 
1;

    let items = [];

    let particles = [];

    let lastTime = 
0;

    let spawnTimer = 
0;

    

    const player = {

        x: 0,

        y: 0,

        width: 80,

        height: 80,

        targetX: 0

    };



    const 
EMOJIS = {

        foods: ['üç£', 
'üç∞', 'üçô', 
'üç©', 'üç¶', 
'üçì'],

        hazard: 'üí£'

    };



    // Redimensionnement

    function resize() {

        const container = document.getElementById('game-container');

        canvas.width = container.clientWidth;

        canvas.height = container.clientHeight;

        player.y = canvas.height - 100;

        player.x = canvas.width / 2 - player.width /
2;

        player.targetX = player.x;

    }



    window.addEventListener('resize', resize);

    resize();



    // Contr√¥les

    canvas.addEventListener('mousemove', (e) => {

        const rect = canvas.getBoundingClientRect();

        player.targetX = e.clientX - rect.left - player.width / 
2;

    });



    canvas.addEventListener('touchmove', (e) => {

        const rect = canvas.getBoundingClientRect();

        player.targetX = e.touches[0].clientX - rect.left - player.width /
2;

        e.preventDefault();

    }, { passive: false });



    // Classes du jeu

    class 
Item {

        constructor() {

            this.size = 
40 + Math.random() * 
20;

            this.x = 
Math.random() * (canvas.width - this.size);

            this.y = -this.size;

            this.isHazard = 
Math.random() < Math.min(0.1 + (level *
0.02), 
0.4);

            this.emoji = 
this.isHazard ? EMOJIS.hazard : 
EMOJIS.foods[Math.floor(Math.random() *
EMOJIS.foods.length)];

            this.speed = (2 +
Math.random() * 
2) * (1 + level * 
0.1);

            this.rotation = 
0;

            this.rotSpeed = (Math.random() -
0.5) * 
0.1;

        }



        update() {

            this.y += 
this.speed;

            this.rotation += 
this.rotSpeed;

            return 
this.y < canvas.height;

        }



        draw() {

            ctx.save();

            ctx.translate(this.x +
this.size/2,
this.y + 
this.size/2);

            ctx.rotate(this.rotation);

            ctx.font = `${this.size}px serif`;

            ctx.textAlign = 'center';

            ctx.textBaseline = 'middle';

            ctx.fillText(this.emoji,
0, 0);

            ctx.restore();

        }

    }



    function createExplosion(x, y, color) {

        for(let i=0; i<10; i++) {

            particles.push({

                x, y,

                vx: (Math.random() -
0.5) * 
10,

                vy: (Math.random() -
0.5) * 
10,

                life: 1.0,

                color: color

            });

        }

    }



    function updateParticles() {

        for(let i = particles.length -
1; i >= 
0; i--) {

            const p = particles[i];

            p.x += p.vx;

            p.y += p.vy;

            p.life -= 0.02;

            if(p.life <= 
0) particles.splice(i, 1);

        }

    }



    function drawParticles() {

        particles.forEach(p => {

            ctx.globalAlpha = p.life;

            ctx.fillStyle = p.color;

            ctx.beginPath();

            ctx.arc(p.x, p.y, 5, 
0, Math.PI *
2);

            ctx.fill();

        });

        ctx.globalAlpha = 1.0;

    }



    function drawPlayer() {

        // Lissage du mouvement du chat

        player.x += (player.targetX - player.x) * 
0.2;

        

        // Limites

        if(player.x < 
0) player.x = 0;

        if(player.x > canvas.width - player.width) player.x = canvas.width - player.width;



        ctx.save();

        // Dessin d'un chat stylis√© kawaii simple

        const x = player.x;

        const y = player.y;

        

        // Oreilles

        ctx.fillStyle = '#ffffff';

        ctx.beginPath();

        ctx.moveTo(x + 10, y + 
30); ctx.lineTo(x + 25, y); ctx.lineTo(x +
40, y + 
25); ctx.fill();

        ctx.beginPath();

        ctx.moveTo(x + 40, y + 
25); ctx.lineTo(x + 55, y); ctx.lineTo(x +
70, y + 
30); ctx.fill();

        

        // Corps/T√™te

        ctx.beginPath();

        ctx.roundRect(x, y + 20, 
80, 60, 
30);

        ctx.fill();

        

        // Visage

        ctx.fillStyle = '#333';

        ctx.beginPath(); ctx.arc(x + 25, y +
50, 4,
0, Math.PI*2); ctx.fill();
// Oeil G

        ctx.beginPath(); ctx.arc(x + 55, y +
50, 4,
0, Math.PI*2); ctx.fill();
// Oeil D

        

        // Bouche (w)

        ctx.strokeStyle = '#333';

        ctx.lineWidth = 2;

        ctx.beginPath();

        ctx.arc(x + 35, y + 
60, 5, 
0, Math.PI);

        ctx.stroke();

        ctx.beginPath();

        ctx.arc(x + 45, y + 
60, 5, 
0, Math.PI);

        ctx.stroke();



        // Joues roses

        ctx.fillStyle = 'rgba(255, 182, 197, 0.6)';

        ctx.beginPath(); ctx.arc(x + 15, y +
60, 6,
0, Math.PI*2); ctx.fill();

        ctx.beginPath(); ctx.arc(x + 65, y +
60, 6,
0, Math.PI*2); ctx.fill();



        ctx.restore();

    }



    function update(time) {

        if(gameState !== 
'PLAYING') return;



        const deltaTime = time - lastTime;

        lastTime = time;



        spawnTimer += deltaTime;

        const spawnInterval = 
Math.max(1200 - (level * 
80), 400);



        if(spawnTimer > spawnInterval) {

            items.push(new 
Item());

            spawnTimer = 0;

        }



        // Difficult√©

        level = Math.floor(score /
10) + 
1;



        for(let i = items.length -
1; i >= 
0; i--) {

            const item = items[i];

            if(!item.update()) {

                items.splice(i, 1);

                continue;

            }



            // Collision Check

            const px = player.x +
10;

            const py = player.y +
20;

            const pw = player.width -
20;

            const ph = player.height -
30;



            if(item.x < px + pw && item.x + item.size > px &&

               item.y < py + ph && item.y + item.size > py) {

                

                if(item.isHazard) {

                    lives--;

                    playSound('hit');

                    createExplosion(item.x + item.size/2, item.y + item.size/2,
'#ff4d4d');

                    livesEl.innerText = lives;

                    if(lives <= 
0) endGame();

                } else {

                    score++;

                    playSound('collect');

                    createExplosion(item.x + item.size/2, item.y + item.size/2,
'#ffeb3b');

                    scoreEl.innerText = score;

                }

                items.splice(i, 1);

            }

        }



        updateParticles();

    }



    function draw() {

        ctx.clearRect(0, 
0, canvas.width, canvas.height);

        

        // Arri√®re-plan d√©coratif (petits coeurs ou pois)

        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';

        for(let i=0; i<5; i++) {

            for(let j=0; j<8; j++) {

                ctx.beginPath();

                ctx.arc(i*120 + 
40, j*120 + 
40, 20, 
0, Math.PI*2);

                ctx.fill();

            }

        }



        items.forEach(item => item.draw());

        drawParticles();

        drawPlayer();



        requestAnimationFrame((time) => {

            update(time);

            draw();

        });

    }



    function startGame() {

        initAudio();

        score = 0;

        lives = 3;

        level = 1;

        items = [];

        particles = [];

        scoreEl.innerText = score;

        livesEl.innerText = lives;

        gameState = 'PLAYING';

        startScreen.classList.add('hidden');

        gameOverScreen.classList.add('hidden');

        lastTime = performance.now();

    }



    function endGame() {

        gameState = 'OVER';

        finalScoreEl.innerText = score;

        gameOverScreen.classList.remove('hidden');

    }



    document.getElementById('start-btn').addEventListener('click', startGame);

    document.getElementById('restart-btn').addEventListener('click', startGame);



    // D√©marrage de la boucle de rendu

    requestAnimationFrame(draw);



</script>

</body>

</html>
