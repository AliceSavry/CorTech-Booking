<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Jelly Pop - Arcade 80s</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Canvas Confetti -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Fredoka+One&display=swap" rel="stylesheet">

    <style>
        /* --- CORE STYLES & CRT EFFECT --- */
        :root {
            --neon-pink: #ff00ff;
            --neon-cyan: #00ffff;
            --neon-yellow: #ffff00;
            --bg-dark: #050011;
        }

        body {
            background-color: #000;
            background-image: radial-gradient(circle at center, #1a0b2e 0%, #000 100%);
            color: white;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            touch-action: none; /* Mobile optimization */
            user-select: none;
            -webkit-user-select: none;
        }

        /* Arcade Cabinet Frame */
        #arcade-cabinet {
            box-shadow: 
                0 0 20px var(--neon-pink),
                inset 0 0 50px rgba(0,0,0,0.8);
            border: 4px solid #333;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        /* Scanline Effect Overlay */
        .scanlines::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 10;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        /* Glow Animations */
        @keyframes text-flicker {
            0% { opacity: 0.1; }
            2% { opacity: 1; }
            8% { opacity: 0.1; }
            9% { opacity: 1; }
            12% { opacity: 0.1; }
            20% { opacity: 1; }
            25% { opacity: 1; }
            30% { opacity: 1; }
            70% { opacity: 0.7; }
            72% { opacity: 0.2; }
            77% { opacity: 0.9; }
            100% { opacity: 0.9; }
        }

        .neon-text-pulse {
            text-shadow: 0 0 10px var(--neon-pink), 0 0 20px var(--neon-pink);
            animation: text-flicker 3s infinite;
        }

        .ui-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 20;
            backdrop-filter: blur(4px);
        }

        .hidden { display: none !important; }

        button.arcade-btn {
            background: linear-gradient(180deg, #ff00ff 0%, #aa00aa 100%);
            border: 2px solid #fff;
            box-shadow: 0 0 15px var(--neon-pink);
            font-family: 'Fredoka One', cursive;
            letter-spacing: 2px;
            transform: scale(1);
            transition: transform 0.1s;
        }
        button.arcade-btn:active {
            transform: scale(0.95);
        }

        /* Shake Animation Class (added via JS) */
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
    </style>
</head>
<body class="h-screen w-screen flex items-center justify-center">

    <!-- GAME CONTAINER -->
    <div id="arcade-cabinet" class="w-full max-w-md h-full max-h-[90vh] aspect-[9/16] md:aspect-[3/4] bg-black relative scanlines shadow-2xl">
        
        <!-- CANVAS LAYER -->
        <canvas id="gameCanvas" class="block w-full h-full"></canvas>

        <!-- HUD (Always visible during gameplay) -->
        <div id="hud" class="absolute top-0 left-0 w-full p-4 flex justify-between items-start pointer-events-none hidden z-10">
            <div class="text-left">
                <p class="text-[10px] text-cyan-300 mb-1">SCORE</p>
                <p id="scoreDisplay" class="text-xl text-white drop-shadow-[0_0_5px_rgba(255,255,255,0.8)]">0</p>
            </div>
            <div class="text-center">
                 <p class="text-[10px] text-yellow-300 mb-1">COMBO</p>
                 <div class="w-24 h-4 border border-white bg-gray-900 rounded-full overflow-hidden">
                     <div id="comboBar" class="h-full bg-gradient-to-r from-yellow-400 to-red-500 w-0 transition-all duration-200"></div>
                 </div>
                 <p id="multiplierDisplay" class="text-xs text-yellow-300 mt-1">x1</p>
            </div>
            <div class="text-right">
                <p class="text-[10px] text-pink-300 mb-1">TEMPS</p>
                <p id="timeDisplay" class="text-xl text-white">60</p>
            </div>
        </div>

        <!-- START SCREEN -->
        <div id="startScreen" class="ui-overlay">
            <h1 class="text-4xl md:text-5xl text-center mb-6 neon-text-pulse font-[Fredoka_One]" style="color:var(--neon-cyan)">NEON<br>JELLY<br>POP</h1>
            <p class="text-[10px] text-pink-300 mb-8 text-center max-w-[80%] leading-relaxed">
                GROUPE LES COULEURS.<br>
                FAIS TOUT EXPLOSER.<br>
                RESTE KAWAII.
            </p>
            <button id="startBtn" class="arcade-btn px-8 py-4 text-xl rounded-full text-white cursor-pointer hover:brightness-110">
                JOUER
            </button>
            <p class="mt-8 text-[8px] text-gray-500 animate-pulse">SOUND REQUIRED</p>
        </div>

        <!-- GAME OVER SCREEN -->
        <div id="gameOverScreen" class="ui-overlay hidden">
            <h2 class="text-3xl text-red-500 mb-2 font-[Fredoka_One] drop-shadow-[0_0_10px_red]">GAME OVER</h2>
            
            <div class="bg-gray-900 border-2 border-cyan-500 p-6 rounded-lg mb-6 text-center w-[80%] shadow-[0_0_15px_#00ffff]">
                <p class="text-xs text-gray-400 mb-2">SCORE FINAL</p>
                <p id="finalScore" class="text-2xl text-white mb-4">0</p>
                
                <p class="text-xs text-gray-400 mb-2">MEILLEUR SCORE</p>
                <p id="highScore" class="text-xl text-yellow-300">0</p>
            </div>

            <button id="restartBtn" class="arcade-btn px-6 py-3 text-lg rounded-full text-white cursor-pointer">
                REJOUER
            </button>
        </div>

    </div>

<script>
/**
 * ARCHITECTURE:
 * 1. SoundEngine: Procedural Audio Generation (No files).
 * 2. Game Logic: Grid management, flood fill, gravity.
 * 3. Rendering: Canvas drawing (Shapes, Particles, Text).
 * 4. Input: Touch/Mouse handling.
 */

/* --- 1. SOUND ENGINE (PROCEDURAL AUDIO) --- */
class SoundEngine {
    constructor() {
        this.ctx = null;
        this.isMuted = false;
        this.bgmOscillators = [];
        this.bgmInterval = null;
        this.tempo = 120;
    }

    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    }

    // Generic Tone Generator
    playTone(freq, type, duration, vol = 0.1) {
        if (this.isMuted || !this.ctx) return;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    // SFX: Pop (varies by pitch based on combo size)
    playPop(size) {
        // Higher pitch for larger groups
        const baseFreq = 300 + (size * 50); 
        this.playTone(baseFreq, 'sine', 0.1, 0.1);
        // Little overtone
        setTimeout(() => this.playTone(baseFreq * 1.5, 'triangle', 0.05, 0.05), 50);
    }

    playBonus() {
        this.playTone(660, 'square', 0.1, 0.1);
        setTimeout(() => this.playTone(880, 'square', 0.3, 0.1), 100);
    }

    playError() {
        this.playTone(150, 'sawtooth', 0.2, 0.1);
    }

    playGameOver() {
        this.stopBGM();
        this.playTone(300, 'sawtooth', 0.5, 0.2);
        setTimeout(() => this.playTone(250, 'sawtooth', 0.5, 0.2), 400);
        setTimeout(() => this.playTone(200, 'sawtooth', 1.0, 0.2), 800);
    }

    // BGM: "Kawaii Bounce" - Faster and cuter
    startBGM() {
        this.stopBGM();
        this.tempo = 150; // Faster!
        let noteIndex = 0;
        
        // High pitched cute melody (C5, E5, G5, A5 range)
        // 0 = rest
        const melody = [
            523.25, 0,      659.25, 0,      // C5, ., E5, .
            783.99, 880.00, 783.99, 659.25, // G5, A5, G5, E5
            523.25, 659.25, 783.99, 523.25, // C5, E5, G5, C5
            659.25, 523.25, 392.00, 523.25  // E5, C5, G4, C5
        ];

        // Bass root notes
        const bassLine = [
            261.63, 261.63, 349.23, 349.23, // C4, F4
            392.00, 392.00, 261.63, 261.63  // G4, C4
        ];
        
        this.bgmInterval = setInterval(() => {
            if(this.ctx && this.ctx.state === 'running'){
                const tick = noteIndex % 16;
                const melNote = melody[tick];
                
                // Melody: High, short, square wave (8-bit style)
                if (melNote > 0) {
                     this.playTone(melNote, 'square', 0.08, 0.05); // Very short staccato
                }

                // Bass: Every 4 ticks (quarter notes), triangle wave (softer)
                if (tick % 4 === 0) {
                    const bassNote = bassLine[Math.floor(tick / 4) % bassLine.length];
                    this.playTone(bassNote / 2, 'triangle', 0.2, 0.08);
                }
                
                noteIndex++;
            }
        }, 60000 / this.tempo / 4); // 16th notes speed
    }

    stopBGM() {
        if (this.bgmInterval) clearInterval(this.bgmInterval);
    }
}

/* --- 2. GAME CLASSES & LOGIC --- */

const COLORS = [
    { name: 'pink', hex: '#FF00FF', face: '^ w ^' },
    { name: 'cyan', hex: '#00FFFF', face: 'o _ o' },
    { name: 'yellow', hex: '#FFFF00', face: '> _ <' },
    { name: 'purple', hex: '#BD00FF', face: '- _ -' }
];

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 5 + 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1.0;
        this.decay = Math.random() * 0.03 + 0.02;
        this.size = Math.random() * 4 + 2;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2; // Gravity
        this.life -= this.decay;
        this.size *= 0.95;
    }

    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class FloatingText {
    constructor(x, y, text, color, scale = 1) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.life = 1.0;
        this.vy = -2;
        this.scale = scale;
    }

    update() {
        this.y += this.vy;
        this.life -= 0.02;
    }

    draw(ctx) {
        if (this.life <= 0) return;
        ctx.globalAlpha = this.life;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.scale, this.scale);
        
        ctx.font = "20px 'Fredoka One'";
        ctx.fillStyle = this.color;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.strokeText(this.text, 0, 0);
        ctx.fillText(this.text, 0, 0);
        
        ctx.restore();
        ctx.globalAlpha = 1.0;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.audio = new SoundEngine();
        
        // Configuration
        this.cols = 7;
        this.rows = 9; // Grid proportion
        this.grid = [];
        this.tileSize = 0;
        this.offsetX = 0;
        this.offsetY = 0;

        // State
        this.state = 'START'; // START, PLAY, GAMEOVER
        this.score = 0;
        this.time = 60;
        this.lastTime = 0;
        this.particles = [];
        this.floatingTexts = [];
        
        // Dopamine Mechanics
        this.comboMeter = 0;
        this.multiplier = 1;
        this.shakeTime = 0;

        // Bindings
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // Inputs
        this.canvas.addEventListener('pointerdown', (e) => this.handleInput(e));
        
        document.getElementById('startBtn').addEventListener('click', () => this.start());
        document.getElementById('restartBtn').addEventListener('click', () => this.reset());

        // High Score
        this.highScore = localStorage.getItem('neonpop_highscore') || 0;
        document.getElementById('highScore').innerText = this.highScore;

        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    resize() {
        const parent = this.canvas.parentElement;
        this.canvas.width = parent.clientWidth;
        this.canvas.height = parent.clientHeight;
        
        // Calculate Tile Size to fit logic grid in canvas
        const tileW = this.canvas.width / this.cols;
        const tileH = this.canvas.height / (this.rows + 1); // +1 for top margin
        this.tileSize = Math.min(tileW, tileH);
        
        // Center grid
        this.offsetX = (this.canvas.width - (this.tileSize * this.cols)) / 2;
        this.offsetY = (this.canvas.height - (this.tileSize * this.rows)) / 2 + 20; // Slight top offset
    }

    initGrid() {
        this.grid = [];
        for (let r = 0; r < this.rows; r++) {
            const row = [];
            for (let c = 0; c < this.cols; c++) {
                row.push(this.randomTile());
            }
            this.grid.push(row);
        }
    }

    randomTile() {
        const typeIdx = Math.floor(Math.random() * COLORS.length);
        return {
            type: typeIdx,
            val: COLORS[typeIdx],
            scale: 1, // For pop animation
            offsetY: -this.canvas.height // For drop-in animation
        };
    }

    start() {
        this.audio.init();
        this.audio.startBGM();
        this.initGrid();
        this.score = 0;
        this.time = 60;
        this.comboMeter = 0;
        this.multiplier = 1;
        this.state = 'PLAY';
        
        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('gameOverScreen').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        
        this.updateUI();
    }

    reset() {
        this.start();
    }

    gameOver() {
        this.state = 'GAMEOVER';
        this.audio.playGameOver();
        
        if (this.score > this.highScore) {
            this.highScore = this.score;
            localStorage.setItem('neonpop_highscore', this.highScore);
            // Confetti for new high score
            confetti({
                particleCount: 150,
                spread: 70,
                origin: { y: 0.6 },
                colors: ['#ff00ff', '#00ffff', '#ffff00']
            });
        }

        document.getElementById('finalScore').innerText = this.score;
        document.getElementById('highScore').innerText = this.highScore;
        document.getElementById('hud').classList.add('hidden');
        document.getElementById('gameOverScreen').classList.remove('hidden');
    }

    handleInput(e) {
        if (this.state !== 'PLAY') return;

        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // Transform to Grid Coords
        const c = Math.floor((x - this.offsetX) / this.tileSize);
        const r = Math.floor((y - this.offsetY) / this.tileSize);

        if (c >= 0 && c < this.cols && r >= 0 && r < this.rows) {
            this.attemptPop(r, c);
        }
    }

    attemptPop(r, c) {
        const tile = this.grid[r][c];
        if (!tile) return; // Empty space

        // Flood Fill algorithm
        const matches = [];
        const visited = new Set();
        const stack = [{r, c}];
        const targetType = tile.type;

        while (stack.length > 0) {
            const curr = stack.pop();
            const key = `${curr.r},${curr.c}`;
            
            if (visited.has(key)) continue;
            visited.add(key);
            matches.push(curr);

            const neighbors = [
                {r: curr.r+1, c: curr.c}, {r: curr.r-1, c: curr.c},
                {r: curr.r, c: curr.c+1}, {r: curr.r, c: curr.c-1}
            ];

            for (let n of neighbors) {
                if (n.r >= 0 && n.r < this.rows && n.c >= 0 && n.c < this.cols) {
                    const nTile = this.grid[n.r][n.c];
                    if (nTile && nTile.type === targetType) {
                        stack.push(n);
                    }
                }
            }
        }

        if (matches.length >= 2) {
            // Valid Pop
            this.executePop(matches, r, c); // Pass center for visuals
        } else {
            this.audio.playError();
            // Wiggle tile
            this.grid[r][c].wiggle = 10; 
        }
    }

    executePop(matches, originR, originC) {
        // 1. Calculate Score
        const basePoints = matches.length * 10;
        const bonus = Math.floor(Math.pow(matches.length, 1.5)); // Exponential reward
        const totalPoints = (basePoints + bonus) * this.multiplier;
        
        this.score += totalPoints;
        
        // 2. Audio & Visuals
        this.audio.playPop(matches.length);
        this.createFloatingText(originC, originR, `+${totalPoints}`, '#fff');
        
        if (matches.length > 5) {
            this.shakeScreen(5); // Small shake
            this.createFloatingText(originC, originR, "NICE!", COLORS[0].hex, 1.5);
            this.addCombo(10);
        }
        if (matches.length > 8) {
            this.shakeScreen(10); // Big shake
            this.createFloatingText(originC, originR, "EPIC!", COLORS[2].hex, 2.0);
            this.audio.playBonus();
            // Confetti burst
            const rect = this.canvas.getBoundingClientRect();
            const px = (this.offsetX + originC * this.tileSize) / this.canvas.width;
            const py = (this.offsetY + originR * this.tileSize) / this.canvas.height;
            confetti({ particleCount: 50, spread: 50, origin: { x: px, y: py } });
            this.addCombo(30);
        } else {
            this.addCombo(5 * matches.length);
        }

        // 3. Remove Tiles & Particles
        matches.forEach(m => {
            const tile = this.grid[m.r][m.c];
            // Spawn particles
            for(let i=0; i<3; i++) {
                const px = this.offsetX + m.c * this.tileSize + this.tileSize/2;
                const py = this.offsetY + m.r * this.tileSize + this.tileSize/2;
                this.particles.push(new Particle(px, py, tile.val.hex));
            }
            this.grid[m.r][m.c] = null;
        });

        // 4. Gravity & Refill
        this.applyGravity();
        this.updateUI();
    }

    applyGravity() {
        setTimeout(() => {
            for (let c = 0; c < this.cols; c++) {
                let writeIdx = this.rows - 1;
                for (let r = this.rows - 1; r >= 0; r--) {
                    if (this.grid[r][c] !== null) {
                        this.grid[writeIdx][c] = this.grid[r][c];
                        if (writeIdx !== r) {
                            // Falling animation logic could go here
                            this.grid[writeIdx][c].offsetY = -10; // Bounce effect
                        }
                        writeIdx--;
                    }
                }
                // Fill remaining top with new
                while (writeIdx >= 0) {
                    this.grid[writeIdx][c] = this.randomTile();
                    writeIdx--;
                }
            }
        }, 50);
    }

    addCombo(amount) {
        this.comboMeter += amount;
        if (this.comboMeter > 100) this.comboMeter = 100;
        
        // Multiplier logic
        if (this.comboMeter >= 90) this.multiplier = 4;
        else if (this.comboMeter >= 50) this.multiplier = 2;
        else this.multiplier = 1;
    }

    shakeScreen(intensity) {
        this.shakeTime = intensity;
        const cabinet = document.getElementById('arcade-cabinet');
        cabinet.classList.remove('shake');
        void cabinet.offsetWidth; // trigger reflow
        cabinet.classList.add('shake');
    }

    createFloatingText(c, r, text, color, scale) {
        const x = this.offsetX + c * this.tileSize + this.tileSize/2;
        const y = this.offsetY + r * this.tileSize;
        this.floatingTexts.push(new FloatingText(x, y, text, color, scale));
    }

    updateUI() {
        document.getElementById('scoreDisplay').innerText = this.score;
        document.getElementById('timeDisplay').innerText = Math.ceil(this.time);
        
        const bar = document.getElementById('comboBar');
        bar.style.width = `${this.comboMeter}%`;
        
        const mulDisplay = document.getElementById('multiplierDisplay');
        mulDisplay.innerText = `x${this.multiplier}`;
        if(this.multiplier > 1) {
            mulDisplay.classList.add('neon-text-pulse');
        } else {
            mulDisplay.classList.remove('neon-text-pulse');
        }
    }

    loop(timestamp) {
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Screen Shake effect rendering offset
        let shakeX = 0;
        let shakeY = 0;
        if (this.shakeTime > 0) {
            shakeX = (Math.random() - 0.5) * this.shakeTime;
            shakeY = (Math.random() - 0.5) * this.shakeTime;
            this.shakeTime *= 0.9; // decay
            if(this.shakeTime < 0.5) this.shakeTime = 0;
        }

        this.ctx.save();
        this.ctx.translate(shakeX, shakeY);

        if (this.state === 'PLAY') {
            this.time -= dt;
            // Combo decay
            this.comboMeter -= (10 * dt); 
            if (this.comboMeter < 0) this.comboMeter = 0;
            // Recalculate multiplier based on decay
            if (this.comboMeter < 50) this.multiplier = 1;
            else if (this.comboMeter < 90) this.multiplier = 2;
            
            this.updateUI();

            if (this.time <= 0) {
                this.gameOver();
            }
        }

        // --- DRAW GRID ---
        for (let r = 0; r < this.rows; r++) {
            // FIX: Guard clause to prevent accessing undefined rows if grid isn't fully initialized
            if (!this.grid[r]) continue; 

            for (let c = 0; c < this.cols; c++) {
                const tile = this.grid[r][c];
                if (!tile) continue;

                // Position
                let x = this.offsetX + c * this.tileSize;
                let y = this.offsetY + r * this.tileSize;
                
                // Animation: Drop In
                if (tile.offsetY < 0) {
                    y += tile.offsetY; // Apply offset
                    tile.offsetY *= 0.8; // Simple easing
                    if(Math.abs(tile.offsetY) < 1) tile.offsetY = 0;
                }

                // Animation: Wiggle (error)
                if (tile.wiggle) {
                    x += Math.sin(Date.now() / 50) * tile.wiggle;
                    tile.wiggle *= 0.8;
                    if(tile.wiggle < 0.5) tile.wiggle = 0;
                }

                const pad = 4;
                const size = this.tileSize - pad * 2;

                // Shape (Rounded Rect)
                this.ctx.fillStyle = tile.val.hex;
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = tile.val.hex;
                
                // Jelly effect: slightly squish based on multiplier excitement
                const squish = Math.sin(Date.now()/200 + c) * (this.comboMeter/400);

                this.ctx.beginPath();
                this.roundRect(this.ctx, x + pad - squish, y + pad + squish, size + squish*2, size - squish, 10);
                this.ctx.fill();

                // Highlight (shiny plastic look)
                this.ctx.shadowBlur = 0;
                this.ctx.fillStyle = 'rgba(255,255,255,0.4)';
                this.ctx.beginPath();
                this.ctx.arc(x + pad + size*0.25, y + pad + size*0.25, size*0.1, 0, Math.PI*2);
                this.ctx.fill();

                // Face (Kawaii)
                this.ctx.fillStyle = 'rgba(0,0,0,0.7)';
                this.ctx.font = `bold ${Math.floor(size/3.5)}px monospace`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(tile.val.face, x + this.tileSize/2, y + this.tileSize/2 + 2);
            }
        }

        // --- DRAW PARTICLES ---
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.update();
            p.draw(this.ctx);
            if (p.life <= 0) this.particles.splice(i, 1);
        }

        // --- DRAW FLOATING TEXT ---
        for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
            const t = this.floatingTexts[i];
            t.update();
            t.draw(this.ctx);
            if (t.life <= 0) this.floatingTexts.splice(i, 1);
        }

        this.ctx.restore();
        requestAnimationFrame(this.loop);
    }

    // Helper for rounded rects
    roundRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
    }
}

// Start Game Logic when DOM is loaded
window.onload = () => {
    const game = new Game();
};

</script>
</body>
</html>
